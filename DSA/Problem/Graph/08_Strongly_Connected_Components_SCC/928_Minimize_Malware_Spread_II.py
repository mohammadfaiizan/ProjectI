"""
928. Minimize Malware Spread II
Difficulty: Hard

Problem:
You are given a network of n nodes represented as an n x n adjacency matrix graph, 
where the ith node is directly connected to the jth node if graph[i][j] == 1.

Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, 
and at least one of those two nodes is infected by malware, then both nodes will be infected by malware.

This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.

We will remove exactly one node from initial. Return the node that, if removed, would result in the minimum M(initial).

If multiple nodes could be removed to achieve the minimum M(initial), return such a node with the smallest index.

Examples:
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0

Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
Output: 1

Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
Output: 1

Constraints:
- n == graph.length
- n == graph[i].length
- 2 <= n <= 300
- graph[i][j] is 0 or 1
- graph[i][i] == 1
- 1 <= initial.length < n
- 0 <= initial[i] <= n - 1
- All the integers in initial are unique
"""

from typing import List, Set
from collections import defaultdict, deque

class Solution:
    def minMalwareSpread_approach1_simulation_optimized(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        Approach 1: Optimized Simulation for Each Removal
        
        Simulate malware spread for each possible removal and find minimum.
        
        Time: O(|initial| * N^2)
        Space: O(N)
        """
        n = len(graph)
        initial_set = set(initial)
        
        def simulate_spread(removed_node):
            """Simulate malware spread without the removed node"""
            if removed_node in initial_set:
                infected = set(initial_set) - {removed_node}
            else:
                infected = set(initial_set)
            
            if not infected:
                return 0
            
            # BFS to spread malware
            queue = deque(infected)
            
            while queue:
                node = queue.popleft()
                
                for neighbor in range(n):
                    if (graph[node][neighbor] == 1 and 
                        neighbor not in infected and 
                        neighbor != removed_node):
                        infected.add(neighbor)
                        queue.append(neighbor)
            
            return len(infected)
        
        min_spread = float('inf')
        best_node = min(initial)
        
        for node in initial:
            spread = simulate_spread(node)
            if spread < min_spread or (spread == min_spread and node < best_node):
                min_spread = spread
                best_node = node
        
        return best_node
    
    def minMalwareSpread_approach2_connected_components_analysis(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        Approach 2: Connected Components Analysis
        
        Analyze connected components and their infection patterns.
        
        Time: O(N^2)
        Space: O(N)
        """
        n = len(graph)
        initial_set = set(initial)
        
        # Find all connected components
        visited = [False] * n
        components = []
        
        def dfs_component(start):
            """DFS to find connected component"""
            component = []
            stack = [start]
            
            while stack:
                node = stack.pop()
                if visited[node]:
                    continue
                
                visited[node] = True
                component.append(node)
                
                for neighbor in range(n):
                    if graph[node][neighbor] == 1 and not visited[neighbor]:
                        stack.append(neighbor)
            
            return component
        
        # Find all components
        for i in range(n):
            if not visited[i]:
                component = dfs_component(i)
                components.append(component)
        
        # Analyze each component
        component_analysis = []
        
        for component in components:
            infected_nodes = [node for node in component if node in initial_set]
            component_analysis.append({
                'nodes': set(component),
                'size': len(component),
                'infected_count': len(infected_nodes),
                'infected_nodes': infected_nodes
            })
        
        def calculate_spread(removed_node):
            """Calculate total spread if we remove a node"""
            total_infected = 0
            
            for comp in component_analysis:
                if removed_node in comp['nodes']:
                    # This component is affected by removal
                    if removed_node in comp['infected_nodes']:
                        remaining_infected = len(comp['infected_nodes']) - 1
                        if remaining_infected > 0:
                            total_infected += comp['size']
                    else:
                        # Removed node wasn't infected, full spread
                        if comp['infected_count'] > 0:
                            total_infected += comp['size']
                else:
                    # Component unaffected by removal
                    if comp['infected_count'] > 0:
                        total_infected += comp['size']
            
            return total_infected
        
        # Find best node to remove
        min_spread = float('inf')
        best_node = min(initial)
        
        for node in initial:
            spread = calculate_spread(node)
            if spread < min_spread or (spread == min_spread and node < best_node):
                min_spread = spread
                best_node = node
        
        return best_node
    
    def minMalwareSpread_approach3_union_find_components(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        Approach 3: Union-Find for Component Analysis
        
        Use Union-Find to efficiently find connected components.
        
        Time: O(N^2 * α(N))
        Space: O(N)
        """
        n = len(graph)
        initial_set = set(initial)
        
        class UnionFind:
            def __init__(self, size):
                self.parent = list(range(size))
                self.rank = [0] * size
                self.component_size = [1] * size
            
            def find(self, x):
                if self.parent[x] != x:
                    self.parent[x] = self.find(self.parent[x])
                return self.parent[x]
            
            def union(self, x, y):
                px, py = self.find(x), self.find(y)
                if px == py:
                    return
                
                if self.rank[px] < self.rank[py]:
                    px, py = py, px
                
                self.parent[py] = px
                self.component_size[px] += self.component_size[py]
                
                if self.rank[px] == self.rank[py]:
                    self.rank[px] += 1
            
            def get_component_size(self, x):
                return self.component_size[self.find(x)]
            
            def get_components(self):
                components = defaultdict(list)
                for i in range(len(self.parent)):
                    components[self.find(i)].append(i)
                return list(components.values())
        
        def calculate_spread_uf(removed_node):
            """Calculate spread using Union-Find analysis"""
            uf = UnionFind(n)
            
            # Build components excluding removed node
            for i in range(n):
                if i == removed_node:
                    continue
                for j in range(i + 1, n):
                    if j == removed_node:
                        continue
                    if graph[i][j] == 1:
                        uf.union(i, j)
            
            # Calculate infected nodes in each component
            total_infected = 0
            processed_components = set()
            
            for node in range(n):
                if node == removed_node:
                    continue
                
                root = uf.find(node)
                if root in processed_components:
                    continue
                
                processed_components.add(root)
                component = [i for i in range(n) if i != removed_node and uf.find(i) == root]
                
                # Check if component has any initially infected nodes
                has_infection = any(node in initial_set for node in component)
                
                if has_infection:
                    total_infected += len(component)
            
            return total_infected
        
        # Find best node to remove
        min_spread = float('inf')
        best_node = min(initial)
        
        for node in initial:
            spread = calculate_spread_uf(node)
            if spread < min_spread or (spread == min_spread and node < best_node):
                min_spread = spread
                best_node = node
        
        return best_node
    
    def minMalwareSpread_approach4_graph_cut_analysis(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        Approach 4: Graph Cut Analysis
        
        Analyze impact of removing nodes on graph cuts and connectivity.
        
        Time: O(|initial| * N^2)
        Space: O(N^2)
        """
        n = len(graph)
        initial_set = set(initial)
        
        def build_adjacency_list():
            """Build adjacency list representation"""
            adj = defaultdict(list)
            for i in range(n):
                for j in range(n):
                    if graph[i][j] == 1 and i != j:
                        adj[i].append(j)
            return adj
        
        def find_reachable(start_nodes, excluded_node, adj):
            """Find all nodes reachable from start nodes"""
            if excluded_node in start_nodes:
                start_nodes = start_nodes - {excluded_node}
            
            if not start_nodes:
                return set()
            
            reachable = set()
            queue = deque(start_nodes)
            reachable.update(start_nodes)
            
            while queue:
                node = queue.popleft()
                
                for neighbor in adj[node]:
                    if neighbor != excluded_node and neighbor not in reachable:
                        reachable.add(neighbor)
                        queue.append(neighbor)
            
            return reachable
        
        adj = build_adjacency_list()
        
        def calculate_impact(removed_node):
            """Calculate impact of removing a specific node"""
            infected_nodes = find_reachable(initial_set, removed_node, adj)
            return len(infected_nodes)
        
        # Analyze impact of removing each initial node
        min_impact = float('inf')
        best_node = min(initial)
        
        for node in initial:
            impact = calculate_impact(node)
            if impact < min_impact or (impact == min_impact and node < best_node):
                min_impact = impact
                best_node = node
        
        return best_node
    
    def minMalwareSpread_approach5_advanced_component_analysis(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        Approach 5: Advanced Component Analysis with Optimization
        
        Advanced analysis considering component structures and infection patterns.
        
        Time: O(N^2)
        Space: O(N)
        """
        n = len(graph)
        initial_set = set(initial)
        
        # Find connected components and analyze infection patterns
        visited = [False] * n
        components_info = []
        
        def analyze_component(start):
            """Analyze a connected component"""
            component = []
            stack = [start]
            
            while stack:
                node = stack.pop()
                if visited[node]:
                    continue
                
                visited[node] = True
                component.append(node)
                
                for neighbor in range(n):
                    if graph[node][neighbor] == 1 and not visited[neighbor]:
                        stack.append(neighbor)
            
            # Analyze infection in this component
            infected_in_component = [node for node in component if node in initial_set]
            
            return {
                'nodes': component,
                'size': len(component),
                'infected_nodes': infected_in_component,
                'infected_count': len(infected_in_component)
            }
        
        # Analyze all components
        for i in range(n):
            if not visited[i]:
                comp_info = analyze_component(i)
                components_info.append(comp_info)
        
        def calculate_optimal_removal():
            """Calculate optimal node to remove"""
            best_reduction = -1
            best_node = min(initial)
            
            for candidate in initial:
                total_reduction = 0
                
                for comp in components_info:
                    if candidate in comp['infected_nodes']:
                        # Removing this node from this component
                        if comp['infected_count'] == 1:
                            # This was the only infected node, save entire component
                            total_reduction += comp['size']
                        # If multiple infected nodes, no reduction
                
                if (total_reduction > best_reduction or 
                    (total_reduction == best_reduction and candidate < best_node)):
                    best_reduction = total_reduction
                    best_node = candidate
            
            return best_node
        
        return calculate_optimal_removal()

def test_minimize_malware_spread():
    """Test all approaches with various test cases"""
    solution = Solution()
    
    test_cases = [
        # (graph, initial, expected)
        ([[1,1,0],[1,1,0],[0,0,1]], [0,1], 0),
        ([[1,1,0],[1,1,1],[0,1,1]], [0,1], 1),
        ([[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], [0,1], 1),
        ([[1,0,0],[0,1,0],[0,0,1]], [0,2], 0),
        ([[1,1,1],[1,1,1],[1,1,1]], [0,1,2], 0),
    ]
    
    approaches = [
        ("Simulation Optimized", solution.minMalwareSpread_approach1_simulation_optimized),
        ("Component Analysis", solution.minMalwareSpread_approach2_connected_components_analysis),
        ("Union-Find", solution.minMalwareSpread_approach3_union_find_components),
        ("Graph Cut Analysis", solution.minMalwareSpread_approach4_graph_cut_analysis),
        ("Advanced Analysis", solution.minMalwareSpread_approach5_advanced_component_analysis),
    ]
    
    for approach_name, func in approaches:
        print(f"\n=== {approach_name} Approach ===")
        for i, (graph, initial, expected) in enumerate(test_cases):
            # Deep copy inputs
            graph_copy = [row[:] for row in graph]
            initial_copy = initial[:]
            result = func(graph_copy, initial_copy)
            status = "✓" if result == expected else "✗"
            print(f"Test {i+1}: {status} expected={expected}, got={result}")

def demonstrate_malware_spread_simulation():
    """Demonstrate malware spread simulation"""
    print("\n=== Malware Spread Simulation Demo ===")
    
    graph = [[1,1,0],[1,1,1],[0,1,1]]
    initial = [0,1]
    
    print(f"Network graph:")
    for i, row in enumerate(graph):
        print(f"  Node {i}: connected to {[j for j, connected in enumerate(row) if connected and i != j]}")
    
    print(f"\nInitially infected: {initial}")
    
    print(f"\nSpread simulation without removal:")
    print(f"  Step 1: Nodes {initial} are infected")
    print(f"  Step 2: Node 0 spreads to Node 1 (already infected)")
    print(f"  Step 3: Node 1 spreads to Node 2")
    print(f"  Final: All nodes {[0,1,2]} infected")
    
    print(f"\nSpread simulation removing Node 0:")
    print(f"  Step 1: Only Node 1 is infected")
    print(f"  Step 2: Node 1 spreads to Node 2")
    print(f"  Final: Nodes {[1,2]} infected (Node 0 saved)")
    
    print(f"\nSpread simulation removing Node 1:")
    print(f"  Step 1: Only Node 0 is infected")
    print(f"  Step 2: Node 0 cannot spread (Node 1 removed)")
    print(f"  Final: Only Node 0 infected (Nodes 1,2 saved)")
    
    solution = Solution()
    result = solution.minMalwareSpread_approach1_simulation_optimized(graph, initial)
    print(f"\nOptimal removal: Node {result}")

def demonstrate_component_analysis():
    """Demonstrate connected component analysis"""
    print("\n=== Component Analysis Demo ===")
    
    graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]
    initial = [0,1]
    
    print(f"Network structure:")
    print(f"  Nodes 0-1-2-3 form a path")
    print(f"  All nodes are in one connected component")
    
    print(f"\nComponent analysis:")
    print(f"  Component 1: Nodes {[0,1,2,3]}")
    print(f"  Infected nodes in component: {initial}")
    print(f"  Component size: 4")
    
    print(f"\nRemoval impact analysis:")
    print(f"  Remove Node 0: Node 1 still spreads to all → 3 infected")
    print(f"  Remove Node 1: Node 0 cannot reach others → 1 infected")
    print(f"  Best choice: Remove Node 1")
    
    solution = Solution()
    result = solution.minMalwareSpread_approach2_connected_components_analysis(graph, initial)
    print(f"\nResult: Remove Node {result}")

def analyze_malware_containment_strategies():
    """Analyze malware containment strategies"""
    print("\n=== Malware Containment Strategies ===")
    
    print("Containment Strategy Analysis:")
    
    print("\n1. **Node Removal Priority:**")
    print("   • Remove nodes that prevent maximum spread")
    print("   • Target nodes in multiple infection paths")
    print("   • Consider network topology and centrality")
    print("   • Prioritize nodes with high connectivity")
    
    print("\n2. **Component Isolation:**")
    print("   • Identify connected components")
    print("   • Analyze infection patterns per component")
    print("   • Target nodes that bridge components")
    print("   • Minimize total infected component size")
    
    print("\n3. **Graph Theory Applications:**")
    print("   • Articulation points for network segmentation")
    print("   • Bridge detection for critical connections")
    print("   • Centrality measures for node importance")
    print("   • Flow analysis for spread prediction")
    
    print("\n4. **Optimization Techniques:**")
    print("   • Greedy selection based on impact")
    print("   • Dynamic programming for complex cases")
    print("   • Simulation for accurate modeling")
    print("   • Heuristics for large-scale networks")
    
    print("\n5. **Real-time Considerations:**")
    print("   • Early detection and response")
    print("   • Adaptive containment strategies")
    print("   • Resource allocation optimization")
    print("   • Multi-stage containment plans")

def demonstrate_network_security_applications():
    """Demonstrate network security applications"""
    print("\n=== Network Security Applications ===")
    
    print("Malware Spread Analysis Applications:")
    
    print("\n1. **Cybersecurity:**")
    print("   • Malware containment in corporate networks")
    print("   • Virus spread prediction and prevention")
    print("   • Network segmentation strategies")
    print("   • Incident response optimization")
    
    print("\n2. **Epidemiology:**")
    print("   • Disease spread modeling")
    print("   • Contact tracing optimization")
    print("   • Quarantine strategy planning")
    print("   • Public health resource allocation")
    
    print("\n3. **Social Networks:**")
    print("   • Information cascade analysis")
    print("   • Misinformation spread control")
    print("   • Influence maximization")
    print("   • Viral marketing optimization")
    
    print("\n4. **Infrastructure Security:**")
    print("   • Power grid failure cascade prevention")
    print("   • Transportation network robustness")
    print("   • Communication system reliability")
    print("   • Supply chain risk management")
    
    print("\n5. **Game Theory:**")
    print("   • Strategic network defense")
    print("   • Resource allocation games")
    print("   • Adversarial network analysis")
    print("   • Security investment optimization")

def compare_algorithm_approaches():
    """Compare different algorithmic approaches"""
    print("\n=== Algorithm Approach Comparison ===")
    
    print("Malware Spread Algorithm Comparison:")
    
    print("\n1. **Simulation Approach:**")
    print("   • Time: O(|initial| × N²)")
    print("   • Space: O(N)")
    print("   • Accurate but potentially slow")
    print("   • Good for small to medium networks")
    
    print("\n2. **Component Analysis:**")
    print("   • Time: O(N²)")
    print("   • Space: O(N)")
    print("   • Efficient for structured networks")
    print("   • Leverages graph connectivity")
    
    print("\n3. **Union-Find:**")
    print("   • Time: O(N² × α(N))")
    print("   • Space: O(N)")
    print("   • Excellent for dynamic connectivity")
    print("   • Good incremental performance")
    
    print("\n4. **Graph Cut Analysis:**")
    print("   • Time: O(|initial| × N²)")
    print("   • Space: O(N²)")
    print("   • Considers network flow properties")
    print("   • Good for flow-based analysis")
    
    print("\n5. **Advanced Analysis:**")
    print("   • Time: O(N²)")
    print("   • Space: O(N)")
    print("   • Optimized component reasoning")
    print("   • Best for production systems")
    
    print("\nSelection Guidelines:")
    print("• **Small networks:** Simulation approach")
    print("• **Structured networks:** Component analysis")
    print("• **Dynamic scenarios:** Union-Find")
    print("• **Large networks:** Advanced analysis")

if __name__ == "__main__":
    test_minimize_malware_spread()
    demonstrate_malware_spread_simulation()
    demonstrate_component_analysis()
    analyze_malware_containment_strategies()
    demonstrate_network_security_applications()
    compare_algorithm_approaches()

"""
Malware Spread and Network Security Concepts:
1. Graph-based Malware Spread Simulation and Analysis
2. Connected Component Analysis for Network Segmentation
3. Optimal Node Removal for Containment Strategies
4. Union-Find Applications in Dynamic Network Analysis
5. Real-time Security Response and Resource Optimization

Key Problem Insights:
- Malware spreads through network connections
- Strategic node removal minimizes total infection
- Connected components determine spread boundaries
- Optimal strategy considers network topology

Algorithm Strategy:
1. Simulate spread for each possible removal
2. Analyze connected components and infection patterns
3. Calculate impact of removing each infected node
4. Select node that minimizes total spread

Network Security Applications:
- Cybersecurity incident response
- Epidemiological modeling and contact tracing
- Social network influence analysis
- Infrastructure failure cascade prevention
- Strategic network defense planning

Optimization Techniques:
- Component-based analysis for efficiency
- Union-Find for dynamic connectivity
- Graph theory for structural insights
- Simulation for accurate modeling

Real-world Impact:
- Corporate network security strategies
- Public health emergency response
- Social media misinformation control
- Critical infrastructure protection
- Strategic defense resource allocation

This problem demonstrates advanced network security analysis
essential for malware containment and epidemic modeling.
"""
